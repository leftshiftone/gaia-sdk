package gaia.sdk.atlas

import gaia.sdk.VariableRegistry

// AUTOGENERATED CLASS. DO NOT MODIFY.
@Suppress("unused", "SpellCheckingInspection")
abstract class AtlasRequest : ArrayList<(VariableRegistry) -> String>() {

    companion object {
        @JvmStatic
        fun query(config: AtlasQueryRequest.() -> Unit): AtlasQueryRequest {
            return AtlasQueryRequest().apply(config)
        }
    }

    val preprocessors = ArrayList<String>()

    abstract fun getStatement():Pair<String, Map<String, Any>>
    class AtlasQueryRequest: AtlasRequest() {
        var addPunctuationPreprocessor : Boolean = false
        var removeSignaturePreprocessor : Boolean = false
        
        class Nlu(private val text:Any, private val merge:Any) : ArrayList<(VariableRegistry) -> String>() {
            fun txt() = add { "txt" }
            fun raw() = add { "raw" }
            fun cls(qualifier:String = "default") = add { 
                val name1 = it.register("qualifier", qualifier)
                "cls(qualifier:\$$name1)" 
            }
            
            class Lex : ArrayList<(VariableRegistry) -> String>() {
                fun lemma() = add { "lemma" }
                fun phonetic() = add { "phonetic" }
                fun pos() = add { "pos" }
                fun base() = add { "base" }
                fun flexions(config: Lex.() -> Unit) = add { Lex().apply(config).render(it, "flexions") }
                fun synonyms(config: Lex.() -> Unit) = add { Lex().apply(config).render(it, "synonyms") }
                fun collocations(config: Lex.() -> Unit) = add { Lex().apply(config).render(it, "collocations") }
                fun hyperonyms(config: Lex.() -> Unit) = add { Lex().apply(config).render(it, "hyperonyms") }
                fun meronyms(config: Lex.() -> Unit) = add { Lex().apply(config).render(it, "meronyms") }
                fun parts(config: Lex.() -> Unit) = add { Lex().apply(config).render(it, "parts") }
                fun abbreviations(config: Lex.() -> Unit) = add { Lex().apply(config).render(it, "abbreviations") }
                fun causations(config: Lex.() -> Unit) = add { Lex().apply(config).render(it, "causations") }
                fun labels() = add { "labels" }

                fun render(registry:VariableRegistry, name:String = "lex"): String {
                    return "$name { ${joinToString(" ") { it(registry) }} }"
                }
            }

            fun lex(config: Lex.() -> Unit) = add {Lex().apply(config).render(it) }
            
            class Dep : ArrayList<(VariableRegistry) -> String>() {
                fun sourcePos() = add { "sourcePos" }
                fun targetPos() = add { "targetPos" }
                fun sourceTag() = add { "sourceTag" }
                fun targetTag() = add { "targetTag" }
                fun sourceIndex() = add { "sourceIndex" }
                fun targetIndex() = add { "targetIndex" }
                fun sourceBase() = add { "sourceBase" }
                fun targetBase() = add { "targetBase" }
                fun main() = add { "main" }
                fun modifier() = add { "modifier" }
                fun parenthesized() = add { "parenthesized" }
                fun source() = add { "source" }
                fun target() = add { "target" }
                fun relation() = add { "relation" }
                fun rawRelation() = add { "rawRelation" }

                fun render(registry:VariableRegistry, name:String = "dep"): String {
                    return "$name { ${joinToString(" ") { it(registry) }} }"
                }
            }

            fun dep(config: Dep.() -> Unit) = add {Dep().apply(config).render(it) }
            
            class Ner : ArrayList<(VariableRegistry) -> String>() {
                
                class Datetime : ArrayList<(VariableRegistry) -> String>() {
                    fun date() = add { "date" }
                    fun date1() = add { "date1" }
                    fun date2() = add { "date2" }
                    fun negation() = add { "negation" }
                    fun fuzzy() = add { "fuzzy" }
                    fun indices() = add { "indices" }

                    fun render(registry:VariableRegistry, name:String = "datetime"): String {
                        return "$name { ${joinToString(" ") { it(registry) }} }"
                    }
                }

                fun datetime(config: Datetime.() -> Unit) = add {Datetime().apply(config).render(it) }
                
                class Duration : ArrayList<(VariableRegistry) -> String>() {
                    fun amount() = add { "amount" }
                    fun amountMin() = add { "amountMin" }
                    fun amountMax() = add { "amountMax" }
                    fun unit() = add { "unit" }
                    fun negation() = add { "negation" }
                    fun indices() = add { "indices" }

                    fun render(registry:VariableRegistry, name:String = "duration"): String {
                        return "$name { ${joinToString(" ") { it(registry) }} }"
                    }
                }

                fun duration(config: Duration.() -> Unit) = add {Duration().apply(config).render(it) }
                
                class Location(private val normalized:Any) : ArrayList<(VariableRegistry) -> String>() {
                    fun name() = add { "name" }
                    fun type() = add { "type" }
                    fun negation() = add { "negation" }
                    fun indices() = add { "indices" }

                    fun render(registry:VariableRegistry, name:String = "location"): String {
                        val name1 = registry.register("normalized", normalized)
                        return "$name(normalized:\$$name1) { ${joinToString(" ") { it(registry) }} }"
                    }
                }

                fun location(normalized:Boolean = true, config: Location.() -> Unit) = add {Location(normalized).apply(config).render(it) }
                
                class Organization : ArrayList<(VariableRegistry) -> String>() {
                    fun name() = add { "name" }
                    fun type() = add { "type" }
                    fun negation() = add { "negation" }
                    fun indices() = add { "indices" }

                    fun render(registry:VariableRegistry, name:String = "organization"): String {
                        return "$name { ${joinToString(" ") { it(registry) }} }"
                    }
                }

                fun organization(config: Organization.() -> Unit) = add {Organization().apply(config).render(it) }
                
                class Accommodation : ArrayList<(VariableRegistry) -> String>() {
                    fun name() = add { "name" }
                    fun type() = add { "type" }
                    fun amount() = add { "amount" }
                    fun negation() = add { "negation" }
                    fun indices() = add { "indices" }

                    fun render(registry:VariableRegistry, name:String = "accommodation"): String {
                        return "$name { ${joinToString(" ") { it(registry) }} }"
                    }
                }

                fun accommodation(config: Accommodation.() -> Unit) = add {Accommodation().apply(config).render(it) }
                
                class Person : ArrayList<(VariableRegistry) -> String>() {
                    fun name() = add { "name" }
                    fun isAdult() = add { "isAdult" }
                    fun age() = add { "age" }
                    fun negation() = add { "negation" }
                    fun indices() = add { "indices" }

                    fun render(registry:VariableRegistry, name:String = "person"): String {
                        return "$name { ${joinToString(" ") { it(registry) }} }"
                    }
                }

                fun person(config: Person.() -> Unit) = add {Person().apply(config).render(it) }
                
                class Price : ArrayList<(VariableRegistry) -> String>() {
                    fun amount() = add { "amount" }
                    fun amountMin() = add { "amountMin" }
                    fun amountMax() = add { "amountMax" }
                    fun currency() = add { "currency" }
                    fun priceCategory() = add { "priceCategory" }
                    fun sensibility() = add { "sensibility" }
                    fun scope() = add { "scope" }
                    fun negation() = add { "negation" }
                    fun indices() = add { "indices" }

                    fun render(registry:VariableRegistry, name:String = "price"): String {
                        return "$name { ${joinToString(" ") { it(registry) }} }"
                    }
                }

                fun price(config: Price.() -> Unit) = add {Price().apply(config).render(it) }
                
                class Age : ArrayList<(VariableRegistry) -> String>() {
                    fun age() = add { "age" }
                    fun negation() = add { "negation" }
                    fun indices() = add { "indices" }

                    fun render(registry:VariableRegistry, name:String = "age"): String {
                        return "$name { ${joinToString(" ") { it(registry) }} }"
                    }
                }

                fun age(config: Age.() -> Unit) = add {Age().apply(config).render(it) }
                fun bool() = add { "bool" }
                fun email() = add { "email" }
                fun url() = add { "url" }
                
                class Custom(private val qualifier:Any) : ArrayList<(VariableRegistry) -> String>() {
                    fun data() = add { "data" }
                    fun negation() = add { "negation" }
                    fun indices() = add { "indices" }

                    fun render(registry:VariableRegistry, name:String = "custom"): String {
                        val name1 = registry.register("qualifier", qualifier)
                        return "$name(qualifier:\$$name1) { ${joinToString(" ") { it(registry) }} }"
                    }
                }

                fun custom(qualifier:String, config: Custom.() -> Unit) = add {Custom(qualifier).apply(config).render(it) }

                fun render(registry:VariableRegistry, name:String = "ner"): String {
                    return "$name { ${joinToString(" ") { it(registry) }} }"
                }
            }

            fun ner(config: Ner.() -> Unit) = add {Ner().apply(config).render(it) }

            fun render(registry:VariableRegistry, name:String = "nlu"): String {
                val name1 = registry.register("text", text)
                val name2 = registry.register("merge", merge)
                return "$name(text:\$$name1, merge:\$$name2) { ${joinToString(" ") { it(registry) }} }"
            }
        }

        fun nlu(text:String, merge:Boolean = false, config: Nlu.() -> Unit) = add {Nlu(text, merge).apply(config).render(it) }

        override fun getStatement():Pair<String, Map<String, Any>> {
            val registry = VariableRegistry()
            val fields = map { it(registry) }.joinToString(" ")
            val statement = "query atlas(${registry.getDatatypes().joinToString(", ")}) { $fields }"
            return Pair(statement, registry.getVariables())
        }
    }


}
